#include <iostream>
using std::cout;
using std::endl;

/****************************************************
	1. 函数模板与普通函数的区别	
		1) 函数模板不允许自动类型转换，必须严格匹配类型
		2) 普通函数可以进行自动类型转换

******************************************************/

template <typename T>
T add(T a, T b)
{
	cout << "函数模板..." << endl;
	return a + b;
}

int add2(int a, int b)
{
	cout << "普通函数..." << endl;
	return a + b;
}

void test1()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	add(a, b);
	
	//函数模板如果使用自动推导类型，是不可以发生隐式类型转换的
	// 因为只有一个类型参数，所以必须严格匹配类型,不能传
	// 两个类型不同的实参，除非模板有两个类型参数
	// add(a, c);	

	// 调用普通函数  普通函数可以隐式类型转换
	add2(a, c);

}



/****************************************************
	2. 函数模板和普通函数的调用规则
		1) c++编译器优先考虑普通函数
		2) 可以通过空模板实参列表的语法,限定编译器只能通过模板匹配
		3) 函数模板可以像普通函数那样可以被重载
		4) 如果函数模板可以产生一个更好的匹配，那么选择模板 ,例如：如果使用普通函数，需要再进行类型转换；而模板函数可以直接接受实参类型进行使用，明显匹配函数模板更佳。
}
******************************************************/

template <typename T>
void print(T a, T b)
{
	cout << "print(T a, T b) 函数模板调用 ..." << endl;
}

void print(int a, int b)
{
	cout << "普通函数调用..." << endl;
}

template <class T>
void print(T a, T b, T c)
{
	cout << "print(T a, T b, T c) 函数模板调用..." << endl;
}

void test2()
{
	// 1. 如果函数模板和普通函数都可以调用（不进行类型转换），那么优先调用普通函数
	int a = 10;
	int b = 20;
	print(a, b);

	// 2. 如果想强制调用函数模板，可以使用空模板参数列表
	print<>(a, b);

	// 3. 函数模板可以发生重载
	print(a, b, 1);

	// 4. 如果函数模板能产生更好的匹配，那么优先使用函数模板
	char c = 'c';
	char d = 'd';
	// 使用普通函数还需要进行类型转换，而模板直接接收类型进行使用
	print(c, d);
}

int main()
{
	test2();
	return 0;
}


